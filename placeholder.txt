first appr:
compile ejs with htmlwebpack plugin with raw-loader after the initial parse
given by html plugin then source the bundled ejs on node 

2nd appr:
dont include views in webpack and connect the dist to index.ejs 

con is that you cant take advantage of the optimizations webpack provide and ejs itself wil not be bundled

-------------------------------------------------------------------------
    "start": "concurrently \"npm:nodemon\" \"npm:browser-sync\"",
    "build": "node backend/configs/prod-build.ts && node backend/dist/app.js",
    "nodemon": "nodemon --config ./backend/nodemon.json",
    "browser-sync": "browser-sync start -p'localhost:3000' --files 'frontend/views/**/*.ejs'",
    "postinstall": "npm run build"

//INFO: webpack dev middleware and browser sync

import webpack from "webpack";
import webpackConfig from "../../frontend/configs/webpack.dev.js";
import devMiddleware from "webpack-dev-middleware";
//import hotMiddleware from "webpack-hot-middleware";
import browserSync from "browser-sync";

export default function setupDevMiddleware(app, port) {
  const compiler = webpack(webpackConfig);

  app.use(
    devMiddleware(compiler, {
      publicPath: webpackConfig.output.publicPath,
      writeToDisk: true,
    }),
  );

  //app.use(hotMiddleware(compiler));

  browserSync.init({
    watch: true,
    proxy: http://localhost:${port},
    port: 3001,
    reload: true,
    ui: false,
    files: ["frontend/views/**/*.ejs", "frontend/dist/**/*.*"],
    open: false,
    watchOptions: {
      ignoreInitial: true,
      ignored: ["node_modules/", "*.txt"],
    },
  });
}
import dotenv from "dotenv";
dotenv.config();
import process from "process";
import path from "path";
import express from "express";
import mysql from "mysql2/promise";
import morgan from "morgan";

const app = express();
const port = process.env.PORT || 8000;

// INFO : development-mode specific middleware
if (process.env.NODE_ENV === "development") {
  (await import("./middlewares/devMiddleware.ts")).default(app, port);
}

// NOTE : src path's from ejs files should be relative to this path
app.use(express.static(path.join(process.cwd(), "frontend/dist")));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.set("view engine", "ejs");
//app.set("view cache", false);
app.set("views", path.join(process.cwd(), "frontend/views"));

// serve ejs files for diff routes
app.get("/", (_req, res) => {
  res.render("index", { title: "" });
});

app.use("/api/test", (_req, res) => {
  res.send("Hello, World!");
});

//app.get("/about", (_req, res) => {
//  res.sendFile(path.join(process.cwd(), "../frontend/dist/about.html"));
//});

//app.set("view engine", "hbs");
//app.set("views", path.join(process.cwd(), "../frontend/views"));

app.use(express.json());
app.use(morgan("dev"));

const conn = await mysql.createConnection({
  host: process.env.SQL_HOST,
  user: process.env.SQL_USER,
  password: process.env.SQL_PASS,
  database: process.env.SQL_DB,
});

// this works, just comment out for now
//try {
//  const [results, fields] = await conn.query(
//    'SELECT * FROM student WHERE name = "Casey"',
//  );
//  console.log({ results }); // results contains rows returned by server
//  console.log({ fields }); // fields contains extra meta data about results, if available
//} catch (err) {
//  console.log(err);
//}

// server
app.listen(port, () => {
  console.log(----- Server is running on port ${port} -----);
});
